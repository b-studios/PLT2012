<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html;charset=utf-8">
  <title>6-lcfae.scala</title>
  <link rel="stylesheet" href="http://jashkenas.github.com/docco/resources/docco.css">
</head>
<body>
<div id='container'>
  <div id="background"></div>
  <div id="jump_to">
    Jump To &hellip;
    <div id="jump_wrapper">
      <div id="jump_page">
          <a class="source" href="10-gc.html">10-gc.scala</a>
          <a class="source" href="2-ae.html">2-ae.scala</a>
          <a class="source" href="3-wae.html">3-wae.scala</a>
          <a class="source" href="4-f1wae.html">4-f1wae.scala</a>
          <a class="source" href="5-fae.html">5-fae.scala</a>
          <a class="source" href="6-lcfae.html">6-lcfae.scala</a>
          <a class="source" href="8-rcfae.html">8-rcfae.scala</a>
          <a class="source" href="9-bcfae.html">9-bcfae.scala</a>
      </div>
    </div>
  </div>
  <table cellspacing=0 cellpadding=0>
  <thead>
    <tr>
      <th class=docs><h1>6-lcfae.scala</h1></th>
      <th class=code></th>
    </tr>
  </thead>
  <tbody>
    <tr id='section-1'>
      <td class=docs>
        <div class="pilwrap">
          <a class="pilcrow" href="#section-1">&#182;</a>
        </div>
        
      </td>
      <td class=code>
        <div class='highlight'><pre><span class="cm">/*</span>
<span class="cm">These are lecture notes for the &quot;Programming Languages and Types&quot; course by Klaus Ostermann </span>
<span class="cm">at the University of Marburg</span>

<span class="cm">loosely based on Sec. 6 of &quot;Programming Languages: Application and Interpretation&quot; by</span>
<span class="cm">Shriram Krishnamurthi</span>

<span class="cm">Please comment/correct/improve these notes via github. Proposals or questions can</span>
<span class="cm">be submitted as an &quot;issue&quot;; proposals for corrections/extensions/improvements can</span>
<span class="cm">be submitted as a &quot;pull request&quot;. You can of course also send an email to Klaus Ostermann */</span>

<span class="cm">/* Lazy Evaluation</span>
<span class="cm"> * ===============</span>
<span class="cm"> *</span>
<span class="cm"> * Motivation for Lazy Evaluation</span>
<span class="cm"> * ------------------------------</span>
<span class="cm"> * read Chap. 7 of PLAI and get acquainted with basic Haskell</span>
<span class="cm"> * (install GHC from www.haskell.org and browse through one of the tutorials)</span>
<span class="cm"> *</span>
<span class="cm"> * read &quot;Why Functional Programming Matters&quot; by John Hughes</span>
<span class="cm"> * available at http://www.cse.chalmers.se/~rjmh/Papers/whyfp.html</span>
<span class="cm"> *  </span>
<span class="cm"> * What lazy evaluation means</span>
<span class="cm"> * --------------------------</span>
<span class="cm"> * The choice of evaluation strategy is a purely semantic change that requires</span>
<span class="cm"> * no change to the syntax.</span>
<span class="cm"> * For this reason we reuse the syntactic definitions of FAE, hence</span>
<span class="cm">:load 5-fae.scala</span>
<span class="cm"> * before executing this script or uncomment the previous line.</span>
<span class="cm"> *</span>
<span class="cm"> * Before we discuss lazy evaluation, we will first discuss a a</span>
<span class="cm"> * related evaluation strategy, call-by-name.</span>
<span class="cm"> *</span>
<span class="cm"> * Call-by-name can be explained very succintly in the substitution-based</span>
<span class="cm"> * interpreter: Instead of evaluating the argument &quot;a&quot; in the &quot;App&quot; case</span>
<span class="cm"> * before substitution, we substitute the unevaluated argument into the body.</span>
<span class="cm"> * The rest remains exactly the same. */</span>

<span class="k">def</span> <span class="n">evalcbn</span><span class="o">(</span><span class="n">e</span><span class="k">:</span> <span class="kt">Exp</span><span class="o">)</span> <span class="k">:</span> <span class="kt">Exp</span> <span class="o">=</span> <span class="n">e</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">Id</span><span class="o">(</span><span class="n">v</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">sys</span><span class="o">.</span><span class="n">error</span><span class="o">(</span><span class="s">&quot;unbound identifier: &quot;</span><span class="o">+</span><span class="n">v</span><span class="o">)</span>
  <span class="k">case</span> <span class="nc">Add</span><span class="o">(</span><span class="n">l</span><span class="o">,</span><span class="n">r</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">evalcbn</span><span class="o">(</span><span class="n">l</span><span class="o">),</span> <span class="n">evalcbn</span><span class="o">(</span><span class="n">r</span><span class="o">))</span> <span class="k">match</span> <span class="o">{</span>
                     <span class="k">case</span> <span class="o">(</span><span class="nc">Num</span><span class="o">(</span><span class="n">x</span><span class="o">),</span><span class="nc">Num</span><span class="o">(</span><span class="n">y</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="nc">Num</span><span class="o">(</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="o">)</span>
                     <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="n">sys</span><span class="o">.</span><span class="n">error</span><span class="o">(</span><span class="s">&quot;can only add numbers&quot;</span><span class="o">)</span>
                    <span class="o">}</span>
  <span class="k">case</span> <span class="nc">App</span><span class="o">(</span><span class="n">f</span><span class="o">,</span><span class="n">a</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">evalcbn</span><span class="o">(</span><span class="n">f</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
     <span class="k">case</span> <span class="nc">Fun</span><span class="o">(</span><span class="n">x</span><span class="o">,</span><span class="n">body</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">evalcbn</span><span class="o">(</span> <span class="n">subst</span><span class="o">(</span><span class="n">body</span><span class="o">,</span><span class="n">x</span><span class="o">,</span> <span class="n">a</span><span class="o">))</span> <span class="c1">// no evaluation of a!</span>
     <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="n">sys</span><span class="o">.</span><span class="n">error</span><span class="o">(</span><span class="s">&quot;can only apply functions&quot;</span><span class="o">)</span>
  <span class="o">}</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="n">e</span> 
<span class="o">}</span>

<span class="cm">/* Does this change the semantics, or is it just an implementation detail?</span>
<span class="cm"> * In other words, is eval(e) == evalcbn(e) for all e ?</span>
<span class="cm"> * Let&#39;s try two former test cases.</span>
<span class="cm"> */</span>
 
<span class="n">assert</span><span class="o">(</span> <span class="n">evalcbn</span><span class="o">(</span><span class="n">test</span><span class="o">)</span> <span class="o">==</span> <span class="n">eval</span><span class="o">(</span><span class="n">test</span><span class="o">))</span>
<span class="n">assert</span><span class="o">(</span><span class="n">evalcbn</span><span class="o">(</span><span class="n">test2</span><span class="o">)</span> <span class="o">==</span> <span class="n">eval</span><span class="o">(</span><span class="n">test2</span><span class="o">))</span>

<span class="cm">/* One can formally prove that if eval and evalcbn both produce a number </span>
<span class="cm"> * then the numbers are equal. Do they also agree if they produce a function?</span>
<span class="cm"> *</span>
<span class="cm"> * Not necessarily. Consider: */</span>

<span class="k">val</span> <span class="n">test3</span> <span class="k">=</span> <span class="nc">App</span><span class="o">(</span><span class="nc">Fun</span><span class="o">(</span><span class="-Symbol">&#39;f</span><span class="o">,</span><span class="nc">Fun</span><span class="o">(</span><span class="-Symbol">&#39;x</span><span class="o">,</span><span class="nc">App</span><span class="o">(</span><span class="-Symbol">&#39;f</span><span class="o">,</span><span class="-Symbol">&#39;x</span><span class="o">))),</span><span class="nc">Add</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">))</span> 

<span class="n">assert</span><span class="o">(</span><span class="n">eval</span><span class="o">(</span><span class="n">test3</span><span class="o">)</span> <span class="o">==</span> <span class="nc">Fun</span><span class="o">(</span><span class="-Symbol">&#39;x</span><span class="o">,</span><span class="nc">App</span><span class="o">(</span><span class="nc">Num</span><span class="o">(</span><span class="mi">3</span><span class="o">),</span><span class="nc">Id</span><span class="o">(</span><span class="-Symbol">&#39;x</span><span class="o">))))</span>
<span class="n">assert</span><span class="o">(</span><span class="n">evalcbn</span><span class="o">(</span><span class="n">test3</span><span class="o">)</span> <span class="o">==</span> <span class="nc">Fun</span><span class="o">(</span><span class="-Symbol">&#39;x</span><span class="o">,</span><span class="nc">App</span><span class="o">(</span><span class="nc">Add</span><span class="o">(</span><span class="nc">Num</span><span class="o">(</span><span class="mi">1</span><span class="o">),</span><span class="nc">Num</span><span class="o">(</span><span class="mi">2</span><span class="o">)),</span><span class="nc">Id</span><span class="o">(</span><span class="-Symbol">&#39;x</span><span class="o">))))</span>

<span class="cm">/* However, if both produce a function, then the functions &quot;behave&quot; the same. </span>
<span class="cm"> * More specifically, the function bodies produced by evalcbn may be </span>
<span class="cm"> * &quot;more evaluated&quot; than those produced by eval. If we would evaluate within</span>
<span class="cm"> * function bodies (also called evaluation &quot;under a lambda&quot;) - which our interpreters</span>
<span class="cm"> * do not do - we could produce the expression returned from eval from the expression</span>
<span class="cm"> * returned by evalcbn. This kind of equivalence is also called &quot;beta-equivalence&quot;.</span>
<span class="cm"> *</span>
<span class="cm"> * Most importantly, however, eval and evalcbn differ with regard to their termination</span>
<span class="cm"> * behavior. We have seen that omega is a diverging expression. In eval, the term */</span>

 <span class="k">val</span> <span class="n">test4</span> <span class="k">=</span> <span class="nc">App</span><span class="o">(</span><span class="nc">Fun</span><span class="o">(</span><span class="-Symbol">&#39;x</span><span class="o">,</span><span class="mi">5</span><span class="o">),</span><span class="n">omega</span><span class="o">)</span>

<span class="cm">/* is hence also diverging. In contrast: */</span>

<span class="n">assert</span><span class="o">(</span><span class="n">evalcbn</span><span class="o">(</span><span class="n">test4</span><span class="o">)</span> <span class="o">==</span> <span class="nc">Num</span><span class="o">(</span><span class="mi">5</span><span class="o">))</span>

<span class="cm">/* Extra material: Infinite lists in FAE (not relevant for exam) </span>
<span class="cm"> * ------------------------------------------------------</span>
<span class="cm"> * Using our call-by-name interpreter, we can express the same kinds of programming</span>
<span class="cm"> * patterns that we have tried in Haskell, such as infinite lists.</span>
<span class="cm"> *</span>
<span class="cm"> * We do not have direct support for lists, but luckily we already know</span>
<span class="cm"> * how to Church-encode them (see also lab-01.scala). Church-encoding can also</span>
<span class="cm"> * be done in FAE. Here is the one for lists: */</span>
<span class="k">val</span> <span class="n">nil</span> <span class="k">=</span> <span class="nc">Fun</span><span class="o">(</span><span class="-Symbol">&#39;c</span><span class="o">,</span> <span class="nc">Fun</span><span class="o">(</span><span class="-Symbol">&#39;e</span><span class="o">,</span> <span class="-Symbol">&#39;e</span><span class="o">))</span>
<span class="k">val</span> <span class="n">cons</span>  <span class="k">=</span> <span class="nc">Fun</span><span class="o">(</span><span class="-Symbol">&#39;x</span><span class="o">,</span> <span class="nc">Fun</span><span class="o">(</span><span class="-Symbol">&#39;xs</span><span class="o">,</span> <span class="nc">Fun</span><span class="o">(</span><span class="-Symbol">&#39;c</span><span class="o">,</span> <span class="nc">Fun</span><span class="o">(</span><span class="-Symbol">&#39;e</span><span class="o">,</span> <span class="nc">App</span><span class="o">(</span><span class="nc">App</span><span class="o">(</span><span class="-Symbol">&#39;c</span><span class="o">,</span> <span class="-Symbol">&#39;x</span><span class="o">),</span> <span class="nc">App</span><span class="o">(</span><span class="nc">App</span><span class="o">(</span><span class="-Symbol">&#39;xs</span><span class="o">,</span> <span class="-Symbol">&#39;c</span><span class="o">),</span><span class="-Symbol">&#39;e</span><span class="o">))))))</span>
<span class="cm">/* For instance, the list 1,2,3 is encoded as: */</span>
<span class="k">val</span> <span class="n">list123</span> <span class="k">=</span> <span class="nc">App</span><span class="o">(</span><span class="nc">App</span><span class="o">(</span><span class="-Symbol">&#39;cons</span><span class="o">,</span><span class="mi">1</span><span class="o">),</span><span class="nc">App</span><span class="o">(</span><span class="nc">App</span><span class="o">(</span><span class="-Symbol">&#39;cons</span><span class="o">,</span><span class="mi">2</span><span class="o">),</span><span class="nc">App</span><span class="o">(</span><span class="nc">App</span><span class="o">(</span><span class="-Symbol">&#39;cons</span><span class="o">,</span><span class="mi">3</span><span class="o">),</span> <span class="-Symbol">&#39;nil</span><span class="o">)))</span>
<span class="cm">/* The map function on lists becomes :*/</span>
<span class="k">val</span> <span class="n">maplist</span> <span class="k">=</span> <span class="nc">Fun</span><span class="o">(</span><span class="-Symbol">&#39;f</span><span class="o">,</span> <span class="nc">Fun</span><span class="o">(</span><span class="-Symbol">&#39;l</span><span class="o">,</span> <span class="nc">App</span><span class="o">(</span><span class="nc">App</span><span class="o">(</span><span class="-Symbol">&#39;l</span><span class="o">,</span> <span class="nc">Fun</span><span class="o">(</span><span class="-Symbol">&#39;x</span><span class="o">,</span> <span class="nc">Fun</span><span class="o">(</span><span class="-Symbol">&#39;xs</span><span class="o">,</span> <span class="nc">App</span><span class="o">(</span><span class="nc">App</span><span class="o">(</span><span class="-Symbol">&#39;cons</span><span class="o">,</span> <span class="nc">App</span><span class="o">(</span><span class="-Symbol">&#39;f</span><span class="o">,</span><span class="-Symbol">&#39;x</span><span class="o">)),</span><span class="-Symbol">&#39;xs</span><span class="o">)))),</span> <span class="-Symbol">&#39;nil</span><span class="o">)))</span>
<span class="cm">/* For instance, we can map the successor function over the 1,2,3 list. */</span>
<span class="k">val</span> <span class="n">test5</span> <span class="k">=</span> <span class="n">wth</span><span class="o">(</span><span class="-Symbol">&#39;cons</span><span class="o">,</span><span class="n">cons</span><span class="o">,</span> 
            <span class="n">wth</span><span class="o">(</span><span class="-Symbol">&#39;nil</span><span class="o">,</span> <span class="n">nil</span><span class="o">,</span> 
            <span class="n">wth</span><span class="o">(</span><span class="-Symbol">&#39;maplist</span><span class="o">,</span> <span class="n">maplist</span><span class="o">,</span>
            <span class="nc">App</span><span class="o">(</span><span class="nc">App</span><span class="o">(</span><span class="-Symbol">&#39;maplist</span><span class="o">,</span> <span class="nc">Fun</span><span class="o">(</span><span class="-Symbol">&#39;x</span><span class="o">,</span> <span class="nc">Add</span><span class="o">(</span><span class="-Symbol">&#39;x</span><span class="o">,</span><span class="mi">1</span><span class="o">))),</span> <span class="n">list123</span><span class="o">))))</span>
<span class="cm">/* Since it is somewhat difficult to print out the resulting list in our primitive language</span>
<span class="cm">   we construct the result we expect explicitly. */</span>
<span class="k">val</span> <span class="n">test5res</span> <span class="k">=</span> <span class="n">wth</span><span class="o">(</span><span class="-Symbol">&#39;cons</span><span class="o">,</span><span class="n">cons</span><span class="o">,</span> 
               <span class="n">wth</span><span class="o">(</span><span class="-Symbol">&#39;nil</span><span class="o">,</span> <span class="n">nil</span><span class="o">,</span> 
                 <span class="nc">App</span><span class="o">(</span><span class="nc">App</span><span class="o">(</span><span class="-Symbol">&#39;cons</span><span class="o">,</span><span class="mi">2</span><span class="o">),</span><span class="nc">App</span><span class="o">(</span><span class="nc">App</span><span class="o">(</span><span class="-Symbol">&#39;cons</span><span class="o">,</span><span class="mi">3</span><span class="o">),</span><span class="nc">App</span><span class="o">(</span><span class="nc">App</span><span class="o">(</span><span class="-Symbol">&#39;cons</span><span class="o">,</span><span class="mi">4</span><span class="o">),</span> <span class="-Symbol">&#39;nil</span><span class="o">)))))</span>
<span class="n">assert</span><span class="o">(</span><span class="n">eval</span><span class="o">(</span><span class="n">test5</span><span class="o">)</span> <span class="o">==</span> <span class="n">eval</span><span class="o">(</span><span class="n">test5res</span><span class="o">))</span>     
<span class="cm">/* Using evalcbn instead of eval the assertion does not hold (why?), but the results are beta-equivalent. */</span>           

<span class="cm">/* We can also construct infinite lists. To this end, we need some form of recursion. We choose </span>
<span class="cm"> * the standard fixed-point operator Y. This operator only works under call-by-name or other </span>
<span class="cm"> * so-called &quot;non-strict&quot; evaluation strategies. */</span>            
<span class="k">val</span> <span class="n">y</span> <span class="k">=</span> <span class="nc">Fun</span><span class="o">(</span><span class="-Symbol">&#39;f</span><span class="o">,</span> <span class="nc">App</span><span class="o">(</span><span class="nc">Fun</span><span class="o">(</span><span class="-Symbol">&#39;x</span><span class="o">,</span><span class="nc">App</span><span class="o">(</span><span class="-Symbol">&#39;f</span><span class="o">,</span> <span class="nc">App</span><span class="o">(</span><span class="-Symbol">&#39;x</span><span class="o">,</span><span class="-Symbol">&#39;x</span><span class="o">))),</span> <span class="nc">Fun</span><span class="o">(</span><span class="-Symbol">&#39;x</span><span class="o">,</span><span class="nc">App</span><span class="o">(</span><span class="-Symbol">&#39;f</span><span class="o">,</span><span class="nc">App</span><span class="o">(</span><span class="-Symbol">&#39;x</span><span class="o">,</span><span class="-Symbol">&#39;x</span><span class="o">)))))</span>
<span class="cm">/* Using Y, we can construct infinite lists, such as the list of all natural numbers. */</span> 
<span class="k">val</span> <span class="n">allnats</span> <span class="k">=</span> <span class="nc">App</span><span class="o">(</span><span class="nc">App</span><span class="o">(</span><span class="-Symbol">&#39;y</span><span class="o">,</span> <span class="nc">Fun</span><span class="o">(</span><span class="-Symbol">&#39;nats</span><span class="o">,</span> <span class="nc">Fun</span><span class="o">(</span><span class="-Symbol">&#39;n</span><span class="o">,</span> <span class="nc">App</span><span class="o">(</span><span class="nc">App</span><span class="o">(</span><span class="-Symbol">&#39;cons</span><span class="o">,</span><span class="-Symbol">&#39;n</span><span class="o">),</span> <span class="nc">App</span><span class="o">(</span><span class="-Symbol">&#39;nats</span><span class="o">,</span> <span class="nc">Add</span><span class="o">(</span><span class="-Symbol">&#39;n</span><span class="o">,</span><span class="mi">1</span><span class="o">)))))),</span><span class="mi">1</span><span class="o">)</span>
<span class="cm">/* We can also perform standard computations on infinite lists, such as mapping the successor function over it. */</span>
<span class="k">val</span> <span class="n">list2toinfty</span> <span class="k">=</span> <span class="n">wth</span><span class="o">(</span><span class="-Symbol">&#39;cons</span><span class="o">,</span><span class="n">cons</span><span class="o">,</span> 
                   <span class="n">wth</span><span class="o">(</span><span class="-Symbol">&#39;nil</span><span class="o">,</span> <span class="n">nil</span><span class="o">,</span> 
                   <span class="n">wth</span><span class="o">(</span><span class="-Symbol">&#39;y</span><span class="o">,</span> <span class="n">y</span><span class="o">,</span> 
                   <span class="n">wth</span><span class="o">(</span><span class="-Symbol">&#39;maplist</span><span class="o">,</span> <span class="n">maplist</span><span class="o">,</span>
                      <span class="nc">App</span><span class="o">(</span><span class="nc">App</span><span class="o">(</span><span class="-Symbol">&#39;maplist</span><span class="o">,</span> <span class="nc">Fun</span><span class="o">(</span><span class="-Symbol">&#39;x</span><span class="o">,</span> <span class="nc">Add</span><span class="o">(</span><span class="-Symbol">&#39;x</span><span class="o">,</span><span class="mi">1</span><span class="o">))),</span> <span class="n">allnats</span><span class="o">)))))</span>
<span class="cm">/* Of course, list2toinfty diverges when we use eval, but it works fine with evalcbn. It is hard to verify the result</span>
<span class="cm"> * due to an almost unreadable output. Hence we propose the following </span>
<span class="cm"> *</span>
<span class="cm"> * Exercise: Extend the language such that you can implement the &quot;take&quot; function as known from Haskell within </span>
<span class="cm"> *           the language  (if0-expressions or something like it are needed for that)</span>
<span class="cm"> *           Now add a &quot;print&quot; function that prints a number on the console. Use it to display the first </span>
<span class="cm"> *           3 list elements of test2toinfty are 2,3,4. </span>
<span class="cm"> *</span>
<span class="cm"> * -- end of extra material --</span>
<span class="cm"> */</span>
 
<span class="cm">/* Let us now consider the question how we can implement call-by-name in the environment-based interpreter.</span>
<span class="cm"> * Translating the idea of not evaluating the function argument to the environment-based version seems to </span>
<span class="cm"> * suggest that the environment should map identifiers to expression instead of values.</span>
<span class="cm"> *</span>
<span class="cm"> * However, we run into the same problems that we had with first-class functions before we introduced closures:</span>
<span class="cm"> * What happens to the deferred substitutions that still have to be applied in the function argument? If</span>
<span class="cm"> * we discard the environment in which the function argument was defined we again introduce a variant of</span>
<span class="cm"> * dynamic scoping.</span>
<span class="cm"> *</span>
<span class="cm"> * Hence, like for closures, we need to store the environment together with the expression. We call such a </span>
<span class="cm"> * pair a _thunk_. An environment hence becomes a mapping from symbols to thunks. Note that environments</span>
<span class="cm"> * and thunks are hence mutually recursive. In Scala, we can hence not use type definitions of the form</span>
<span class="cm"> *</span>
<span class="cm"> * type Thunk = (Exp, Env)</span>
<span class="cm"> * type Env = Map[Symbol, Thunk]</span>
<span class="cm"> *</span>
<span class="cm"> * Instead, we use a Scala class Env to express this recursion.</span>
<span class="cm"> *</span>
<span class="cm"> * Since we want to experiment with different variants of how to generate and evaluate thunks we first</span>
<span class="cm"> * create a parameterizable variant of the evaluator that leaves open how to </span>
<span class="cm"> * i)represent thunks (type Thunk)</span>
<span class="cm"> * ii) create thunks (method delay)</span>
<span class="cm"> * iii) evaluate thunks (method force).</span>
<span class="cm"> *</span>
<span class="cm"> * Hint: Research on the internet what abstract type members in Scala are.</span>
<span class="cm"> *       For instance, here: http://www.scala-lang.org/node/105</span>
<span class="cm"> */</span>
<span class="k">trait</span> <span class="nc">CBN</span> <span class="o">{</span>
    <span class="k">type</span> <span class="kt">Thunk</span>
    
    <span class="k">case</span> <span class="k">class</span> <span class="nc">Env</span><span class="o">(</span><span class="n">map</span><span class="k">:</span> <span class="kt">Map</span><span class="o">[</span><span class="kt">Symbol</span>, <span class="kt">Thunk</span><span class="o">])</span> <span class="o">{</span>
      <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">key</span><span class="k">:</span> <span class="kt">Symbol</span><span class="o">)</span> <span class="k">=</span> <span class="n">map</span><span class="o">.</span><span class="n">apply</span><span class="o">(</span><span class="n">key</span><span class="o">)</span>
      <span class="k">def</span> <span class="o">+(</span><span class="n">other</span><span class="k">:</span> <span class="o">(</span><span class="kt">Symbol</span><span class="o">,</span> <span class="kt">Thunk</span><span class="o">))</span> <span class="k">:</span> <span class="kt">Env</span> <span class="o">=</span> <span class="nc">Env</span><span class="o">(</span><span class="n">map</span><span class="o">+</span><span class="n">other</span><span class="o">)</span>
    <span class="o">}</span>

    <span class="k">def</span> <span class="n">delay</span><span class="o">(</span><span class="n">e</span><span class="k">:</span> <span class="kt">Exp</span><span class="o">,</span> <span class="n">env</span><span class="k">:</span> <span class="kt">Env</span><span class="o">)</span> <span class="k">:</span> <span class="kt">Thunk</span>
    <span class="k">def</span> <span class="n">force</span><span class="o">(</span><span class="n">t</span><span class="k">:</span> <span class="kt">Thunk</span><span class="o">)</span> <span class="k">:</span> <span class="kt">Value</span></pre></div>
      </td>
    </tr>
    <tr id='section-2'>
      <td class=docs>
        <div class="pilwrap">
          <a class="pilcrow" href="#section-2">&#182;</a>
        </div>
        <p>since values also depend on Env and hence on Thunk they need to
be defined within this trait    </p>
      </td>
      <td class=code>
        <div class='highlight'><pre>    <span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Value</span>
    <span class="k">case</span> <span class="k">class</span> <span class="nc">NumV</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Value</span>
    <span class="k">case</span> <span class="k">class</span> <span class="nc">ClosureV</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">Fun</span><span class="o">,</span> <span class="n">env</span><span class="k">:</span> <span class="kt">Env</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Value</span> 
    <span class="k">def</span> <span class="n">eval</span><span class="o">(</span><span class="n">e</span><span class="k">:</span> <span class="kt">Exp</span><span class="o">,</span> <span class="n">env</span><span class="k">:</span> <span class="kt">Env</span><span class="o">)</span> <span class="k">:</span> <span class="kt">Value</span> <span class="o">=</span> <span class="n">e</span> <span class="k">match</span> <span class="o">{</span>
      <span class="k">case</span> <span class="nc">Id</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">force</span><span class="o">(</span><span class="n">env</span><span class="o">(</span><span class="n">x</span><span class="o">))</span> <span class="c1">// force evaluation of thunk if identifier is evaluated</span>
      <span class="k">case</span> <span class="nc">Add</span><span class="o">(</span><span class="n">l</span><span class="o">,</span><span class="n">r</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">{</span>
        <span class="o">(</span><span class="n">eval</span><span class="o">(</span><span class="n">l</span><span class="o">,</span><span class="n">env</span><span class="o">),</span> <span class="n">eval</span><span class="o">(</span><span class="n">r</span><span class="o">,</span><span class="n">env</span><span class="o">))</span> <span class="k">match</span> <span class="o">{</span>
          <span class="k">case</span> <span class="o">(</span><span class="nc">NumV</span><span class="o">(</span><span class="n">v1</span><span class="o">),</span><span class="nc">NumV</span><span class="o">(</span><span class="n">v2</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="nc">NumV</span><span class="o">(</span><span class="n">v1</span><span class="o">+</span><span class="n">v2</span><span class="o">)</span>
          <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="n">sys</span><span class="o">.</span><span class="n">error</span><span class="o">(</span><span class="s">&quot;can only add numbers&quot;</span><span class="o">)</span>
        <span class="o">}</span>
      <span class="o">}</span>
      <span class="k">case</span> <span class="nc">App</span><span class="o">(</span><span class="n">f</span><span class="o">,</span><span class="n">a</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">eval</span><span class="o">(</span><span class="n">f</span><span class="o">,</span><span class="n">env</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span></pre></div>
      </td>
    </tr>
    <tr id='section-3'>
      <td class=docs>
        <div class="pilwrap">
          <a class="pilcrow" href="#section-3">&#182;</a>
        </div>
        <p>delay argument expression and add it to environment of the closure</p>

      </td>
      <td class=code>
        <div class='highlight'><pre>        <span class="k">case</span> <span class="nc">ClosureV</span><span class="o">(</span><span class="n">f</span><span class="o">,</span><span class="n">cenv</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">eval</span><span class="o">(</span><span class="n">f</span><span class="o">.</span><span class="n">body</span><span class="o">,</span> <span class="n">cenv</span> <span class="o">+</span> <span class="o">(</span><span class="n">f</span><span class="o">.</span><span class="n">param</span> <span class="o">-&gt;</span> <span class="n">delay</span><span class="o">(</span><span class="n">a</span><span class="o">,</span><span class="n">env</span><span class="o">)))</span>
        <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="n">sys</span><span class="o">.</span><span class="n">error</span><span class="o">(</span><span class="s">&quot;can only apply functions&quot;</span><span class="o">)</span>
      <span class="o">}</span>
      <span class="k">case</span> <span class="nc">Num</span><span class="o">(</span><span class="n">n</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">NumV</span><span class="o">(</span><span class="n">n</span><span class="o">)</span>
      <span class="k">case</span> <span class="n">f</span><span class="nd">@Fun</span><span class="o">(</span><span class="n">x</span><span class="o">,</span><span class="n">body</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">ClosureV</span><span class="o">(</span><span class="n">f</span><span class="o">,</span><span class="n">env</span><span class="o">)</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="cm">/* Let&#39;s now create an instance of CBN that corresponds to the substitution-based call-by-name</span>
<span class="cm"> * interpreter. A thunk is just a pair of expression and environment. Forcing a thunk just</span>
<span class="cm"> * evaluates it in the stored environment.</span>
<span class="cm"> *</span>
<span class="cm"> * To understand what is going on during evaluation of tests we trace argument evaluation by a </span>
<span class="cm"> * printout to the console.</span>
<span class="cm"> */</span>
 
<span class="k">object</span> <span class="nc">CallByName</span> <span class="k">extends</span> <span class="nc">CBN</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">Thunk</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Exp</span><span class="o">,</span><span class="nc">Env</span><span class="o">)</span>
  <span class="k">def</span> <span class="n">delay</span><span class="o">(</span><span class="n">e</span><span class="k">:</span> <span class="kt">Exp</span><span class="o">,</span> <span class="n">env</span><span class="k">:</span> <span class="kt">Env</span><span class="o">)</span> <span class="k">=</span> <span class="o">(</span><span class="n">e</span><span class="o">,</span><span class="n">env</span><span class="o">)</span>
  <span class="k">def</span> <span class="n">force</span><span class="o">(</span><span class="n">t</span><span class="k">:</span> <span class="kt">Thunk</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
    <span class="n">println</span><span class="o">(</span><span class="s">&quot;Forcing evaluation of expression: &quot;</span><span class="o">+</span><span class="n">t</span><span class="o">.</span><span class="n">_1</span><span class="o">)</span>
    <span class="n">eval</span><span class="o">(</span><span class="n">t</span><span class="o">.</span><span class="n">_1</span><span class="o">,</span><span class="n">t</span><span class="o">.</span><span class="n">_2</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="n">assert</span><span class="o">(</span><span class="nc">CallByName</span><span class="o">.</span><span class="n">eval</span><span class="o">(</span><span class="n">test</span><span class="o">,</span> <span class="nc">CallByName</span><span class="o">.</span><span class="nc">Env</span><span class="o">(</span><span class="nc">Map</span><span class="o">.</span><span class="n">empty</span><span class="o">))</span> <span class="o">==</span> <span class="nc">CallByName</span><span class="o">.</span><span class="nc">NumV</span><span class="o">(</span><span class="mi">12</span><span class="o">))</span>
<span class="cm">/* Call-by-need</span>
<span class="cm"> * ------------</span>
<span class="cm"> * Call-by-name is rather wasteful: If an argument is used n times in the body, the argument</span>
<span class="cm"> * expression is re-evaluated n-times. For instance, in */</span>
<span class="k">val</span> <span class="n">cbntest</span> <span class="k">=</span> <span class="n">wth</span><span class="o">(</span><span class="-Symbol">&#39;double</span><span class="o">,</span> <span class="nc">Fun</span><span class="o">(</span><span class="-Symbol">&#39;x</span><span class="o">,</span> <span class="nc">Add</span><span class="o">(</span><span class="-Symbol">&#39;x</span><span class="o">,</span><span class="-Symbol">&#39;x</span><span class="o">)),</span>
               <span class="nc">App</span><span class="o">(</span><span class="-Symbol">&#39;double</span><span class="o">,</span> <span class="nc">Add</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">)))</span>
<span class="cm">/* the sum of 2 and 3 is computed twice. </span>
<span class="cm"> * If the argument is passed again to another function,</span>
<span class="cm"> * this may lead to an exponential blow-up.</span>
<span class="cm"> *</span>
<span class="cm"> * Example: */</span>

<span class="k">val</span> <span class="n">blowup</span>  <span class="k">=</span> <span class="n">wth</span><span class="o">(</span><span class="-Symbol">&#39;a</span><span class="o">,</span> <span class="nc">Fun</span><span class="o">(</span><span class="-Symbol">&#39;x</span><span class="o">,</span> <span class="nc">Add</span><span class="o">(</span><span class="-Symbol">&#39;x</span><span class="o">,</span><span class="-Symbol">&#39;x</span><span class="o">)),</span>
              <span class="n">wth</span><span class="o">(</span><span class="-Symbol">&#39;b</span><span class="o">,</span> <span class="nc">Fun</span><span class="o">(</span><span class="-Symbol">&#39;x</span><span class="o">,</span> <span class="nc">Add</span><span class="o">(</span><span class="nc">App</span><span class="o">(</span><span class="-Symbol">&#39;a</span><span class="o">,</span><span class="-Symbol">&#39;x</span><span class="o">),</span> <span class="nc">App</span><span class="o">(</span><span class="-Symbol">&#39;a</span><span class="o">,</span><span class="-Symbol">&#39;x</span><span class="o">))),</span>
              <span class="n">wth</span><span class="o">(</span><span class="-Symbol">&#39;c</span><span class="o">,</span> <span class="nc">Fun</span><span class="o">(</span><span class="-Symbol">&#39;x</span><span class="o">,</span> <span class="nc">Add</span><span class="o">(</span><span class="nc">App</span><span class="o">(</span><span class="-Symbol">&#39;b</span><span class="o">,</span><span class="-Symbol">&#39;x</span><span class="o">),</span> <span class="nc">App</span><span class="o">(</span><span class="-Symbol">&#39;b</span><span class="o">,</span><span class="-Symbol">&#39;x</span><span class="o">))),</span>
              <span class="n">wth</span><span class="o">(</span><span class="-Symbol">&#39;d</span><span class="o">,</span> <span class="nc">Fun</span><span class="o">(</span><span class="-Symbol">&#39;x</span><span class="o">,</span> <span class="nc">Add</span><span class="o">(</span><span class="nc">App</span><span class="o">(</span><span class="-Symbol">&#39;c</span><span class="o">,</span><span class="-Symbol">&#39;x</span><span class="o">),</span> <span class="nc">App</span><span class="o">(</span><span class="-Symbol">&#39;c</span><span class="o">,</span><span class="-Symbol">&#39;x</span><span class="o">))),</span>
              <span class="n">wth</span><span class="o">(</span><span class="-Symbol">&#39;e</span><span class="o">,</span> <span class="nc">Fun</span><span class="o">(</span><span class="-Symbol">&#39;x</span><span class="o">,</span> <span class="nc">Add</span><span class="o">(</span><span class="nc">App</span><span class="o">(</span><span class="-Symbol">&#39;d</span><span class="o">,</span><span class="-Symbol">&#39;x</span><span class="o">),</span> <span class="nc">App</span><span class="o">(</span><span class="-Symbol">&#39;d</span><span class="o">,</span><span class="-Symbol">&#39;x</span><span class="o">))),</span>
              <span class="n">wth</span><span class="o">(</span><span class="-Symbol">&#39;f</span><span class="o">,</span> <span class="nc">Fun</span><span class="o">(</span><span class="-Symbol">&#39;x</span><span class="o">,</span> <span class="nc">Add</span><span class="o">(</span><span class="nc">App</span><span class="o">(</span><span class="-Symbol">&#39;e</span><span class="o">,</span><span class="-Symbol">&#39;x</span><span class="o">),</span> <span class="nc">App</span><span class="o">(</span><span class="-Symbol">&#39;e</span><span class="o">,</span><span class="-Symbol">&#39;x</span><span class="o">))),</span>
              <span class="nc">App</span><span class="o">(</span><span class="-Symbol">&#39;f</span><span class="o">,</span> <span class="nc">Add</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">))))))))</span>
<span class="cm">/*</span>
<span class="cm"> * Can we do better? Yes, by caching the value</span>
<span class="cm"> * when the argument expression is evaluated for the first time. This evaluation strategy</span>
<span class="cm"> * is called _call-by-need_. </span>
<span class="cm"> *</span>
<span class="cm"> * Caching is easy to implement in Scala:</span>
<span class="cm"> */</span>

 <span class="k">object</span> <span class="nc">CallByNeed</span> <span class="k">extends</span> <span class="nc">CBN</span> <span class="o">{</span>
  <span class="k">case</span> <span class="k">class</span> <span class="nc">MemoThunk</span><span class="o">(</span><span class="n">e</span><span class="k">:</span> <span class="kt">Exp</span><span class="o">,</span> <span class="n">env</span><span class="k">:</span> <span class="kt">Env</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">var</span> <span class="n">cache</span><span class="k">:</span> <span class="kt">Value</span> <span class="o">=</span> <span class="kc">null</span>
  <span class="o">}</span>
  <span class="k">type</span> <span class="kt">Thunk</span> <span class="o">=</span> <span class="nc">MemoThunk</span>
  <span class="k">def</span> <span class="n">delay</span><span class="o">(</span><span class="n">e</span><span class="k">:</span> <span class="kt">Exp</span><span class="o">,</span> <span class="n">env</span><span class="k">:</span> <span class="kt">Env</span><span class="o">)</span> <span class="k">=</span> <span class="nc">MemoThunk</span><span class="o">(</span><span class="n">e</span><span class="o">,</span><span class="n">env</span><span class="o">)</span>
  <span class="k">def</span> <span class="n">force</span><span class="o">(</span><span class="n">t</span><span class="k">:</span> <span class="kt">Thunk</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">t</span><span class="o">.</span><span class="n">cache</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">println</span><span class="o">(</span><span class="s">&quot;Forcing evaluation of expression: &quot;</span><span class="o">+</span><span class="n">t</span><span class="o">.</span><span class="n">e</span><span class="o">)</span>
      <span class="n">t</span><span class="o">.</span><span class="n">cache</span> <span class="k">=</span> <span class="n">eval</span><span class="o">(</span><span class="n">t</span><span class="o">.</span><span class="n">e</span><span class="o">,</span> <span class="n">t</span><span class="o">.</span><span class="n">env</span><span class="o">)</span>
    <span class="o">}</span> <span class="k">else</span> <span class="n">println</span> <span class="o">(</span><span class="s">&quot;Reusing cached value &quot;</span><span class="o">+</span><span class="n">t</span><span class="o">.</span><span class="n">cache</span><span class="o">+</span><span class="s">&quot; for expression &quot;</span><span class="o">+</span><span class="n">t</span><span class="o">.</span><span class="n">e</span><span class="o">)</span>
    <span class="n">t</span><span class="o">.</span><span class="n">cache</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="cm">/* For instance, compare call-by-need and call-by-name in cbntest or blowup. </span>
<span class="cm"> *</span>
<span class="cm"> * However, the meta-language (i.e., the subset of Scala features) used in the</span>
<span class="cm"> * interpreter has become more complicated: Since we are using mutation, the order</span>
<span class="cm"> * of evaluation and aliasing of object references becomes important. Luckily, </span>
<span class="cm"> * call-by-need agrees with call-by-name with regard to produced values and termination</span>
<span class="cm"> * behavior, hence it is usually not necessary to reason about programs with the</span>
<span class="cm"> * call-by-need semantics. If, however, one wants to reason about the performance</span>
<span class="cm"> * of a program in a call-by-need setting, one has to take these additional complications</span>
<span class="cm"> * into account. In practice, it is even worse, since languages like Haskell perform</span>
<span class="cm"> * additional optimizations that, for instance, switch to call-by-value if an analysis</span>
<span class="cm"> * can determine that an argument will definitely be used (lookup &quot;strictness analysis&quot;). </span>
<span class="cm"> </span>
<span class="cm"> Topics for class discussion:</span>
<span class="cm"> - Is it a good idea to mix a language with implicit mutation (such as Java, Scala, C++, Python, ...)</span>
<span class="cm">   with lazy evaluation?</span>
<span class="cm"> - How can one simulate lazy evaluation in an eager language? </span>
<span class="cm">   Basic idea: &#39;Lambda&#39; as evaluation firewall.</span>
<span class="cm"> */</span>
 </pre></div>
      </td>
    </tr>
  </table>
</div>
</body>
