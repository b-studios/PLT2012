<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>16-firstclasscontinuations.scala</title>
  <link rel="stylesheet" href="../recources/style.css">
</head>
<body>
  <a href="https://github.com/klauso/PLT2012"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_red_aa0000.png" alt="Fork me on GitHub"></a>
  <header>
  <nav>
    <ul>    
        <li><a href="10-gc.html">10-gc.scala</a></li>
        <li><a href="11-syntacticvsmeta.html">11-syntacticvsmeta.scala</a></li>
        <li><a href="12-churchencoding.html">12-churchencoding.scala</a></li>
        <li><a href="13-cpstransformation.html">13-cpstransformation.scala</a></li>
        <li><a href="14-cpstransformation2.html">14-cpstransformation2.scala</a></li>
        <li><a href="16-firstclasscontinuations.html">16-firstclasscontinuations.scala</a></li>
        <li><a href="17-defunctionalization.html">17-defunctionalization.scala</a></li>
        <li><a href="18-abstractmachines.html">18-abstractmachines.scala</a></li>
        <li><a href="2-ae.html">2-ae.scala</a></li>
        <li><a href="20-normalization.html">20-normalization.scala</a></li>
        <li><a href="21-OO.html">21-OO.scala</a></li>
        <li><a href="26-OO-typed.html">26-OO-typed.scala</a></li>
        <li><a href="3-wae.html">3-wae.scala</a></li>
        <li><a href="4-f1wae.html">4-f1wae.scala</a></li>
        <li><a href="5-fae.html">5-fae.scala</a></li>
        <li><a href="6-lcfae.html">6-lcfae.scala</a></li>
        <li><a href="8-rcfae.html">8-rcfae.scala</a></li>
        <li><a href="9-bcfae.html">9-bcfae.scala</a></li>
    </ul>
  </nav>
  </header>
  <article id="documentation">
    <section id='section-1'>
      <div class="docs"><p>These are lecture notes for the &ldquo;Programming Languages and Types&rdquo; course by Klaus Ostermann 
at the University of Marburg</p>

<p>loosely based on Sec. 20 of &ldquo;Programming Languages: Application and Interpretation&rdquo; by
Shriram Krishnamurthi</p>

<p>Please comment/correct/improve these notes via github. Proposals or questions can
be submitted as an &ldquo;issue&rdquo;; proposals for corrections/extensions/improvements can
be submitted as a &ldquo;pull request&rdquo;. You can of course also send an email to Klaus Ostermann</p></div>
      <div class="code"><code class='highlight'><pre></pre></code></div>
    </section>
    <section id='section-2'>
      <div class="docs"><p>Today&rsquo;s goal is to formalize first-class continuations as illustrated by Scheme&rsquo;s let/cc 
construct. In the previous lecture we have learned why first class continuations are
a powerful language construct. Today we learn the semantics of first-class continuations
by extending our interpreter to support letcc. Here is the abstract syntax of the
language we want to extend:</p></div>
      <div class="code"><code class='highlight'><pre><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Exp</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">Num</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Exp</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">Id</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">Symbol</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Exp</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">Add</span><span class="o">(</span><span class="n">lhs</span><span class="k">:</span> <span class="kt">Exp</span><span class="o">,</span> <span class="n">rhs</span><span class="k">:</span> <span class="kt">Exp</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Exp</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">Fun</span><span class="o">(</span><span class="n">param</span><span class="k">:</span> <span class="kt">Symbol</span><span class="o">,</span> <span class="n">body</span><span class="k">:</span> <span class="kt">Exp</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Exp</span>
<span class="k">implicit</span> <span class="k">def</span> <span class="n">num2exp</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="nc">Num</span><span class="o">(</span><span class="n">n</span><span class="o">)</span>
<span class="k">implicit</span> <span class="k">def</span> <span class="n">id2exp</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">Symbol</span><span class="o">)</span> <span class="k">=</span> <span class="nc">Id</span><span class="o">(</span><span class="n">s</span><span class="o">)</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">App</span> <span class="o">(</span><span class="n">funExpr</span><span class="k">:</span> <span class="kt">Exp</span><span class="o">,</span> <span class="n">argExpr</span><span class="k">:</span> <span class="kt">Exp</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Exp</span></pre></code></div>
    </section>
    <section id='section-3'>
      <div class="docs"><p>The abstract syntax of Letcc is as follows:</p></div>
      <div class="code"><code class='highlight'><pre><span class="k">case</span> <span class="k">class</span> <span class="nc">Letcc</span><span class="o">(</span><span class="n">param</span><span class="k">:</span> <span class="kt">Symbol</span><span class="o">,</span> <span class="n">body</span><span class="k">:</span> <span class="kt">Exp</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Exp</span></pre></code></div>
    </section>
    <section id='section-4'>
      <div class="docs"><p>But how do we implement letcc? How do we get hold of the rest of the computation of the
object (=interpreted) program? </p>

<p>One idea would be to CPS-transform the object program. Then we have the current continuation
available and could store it in environments etc.</p>

<p>However, we want to give a direct semantics to first-class continuations, without first 
transforming the object program. </p>

<p><strong>Insight:</strong> If we would CPS-transform the interpreter, the continuation of the interpreter also
represents, in some way, the continuation of the object program. The difference is that
it represents what&rsquo;s left to do in the interpreter and not in the object program. However,
what is left in the interpreter <em>is</em> what is left in the object program.</p>

<p>Hence we are faced with two tasks:</p>

<ol>
<li>CPS-transform the interpreter</li>
<li>add a branch for Letcc to the interpreter.</li>
</ol>

<p>Let&rsquo;s start with the standard infrastructure of values and environments.</p></div>
      <div class="code"><code class='highlight'><pre><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Value</span>
<span class="k">type</span> <span class="kt">Env</span> <span class="o">=</span> <span class="nc">Map</span><span class="o">[</span><span class="kt">Symbol</span>, <span class="kt">Value</span><span class="o">]</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">NumV</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Value</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">ClosureV</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">Fun</span><span class="o">,</span> <span class="n">env</span><span class="k">:</span> <span class="kt">Env</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Value</span></pre></code></div>
    </section>
    <section id='section-5'>
      <div class="docs"><p>How do we represent values that represent continuations? Since we want to
represent an object language continuation by a meta language continuation,
we need to be able to wrap a meta language continuation as an object language
value. This continuation will always accept some other object language value:</p></div>
      <div class="code"><code class='highlight'><pre><span class="k">case</span> <span class="k">class</span> <span class="nc">ContV</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">Value</span> <span class="o">=&gt;</span> <span class="nc">Nothing</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Value</span></pre></code></div>
    </section>
    <section id='section-6'>
      <div class="docs"><p>We also need a syntactic construct to apply continuations. One way to provide
such a construct would be to add a new syntactic category of continuation application.
We will instead do what Scheme and other languages also do: We overload the
normal function applicaton construct and also use it for application of continuations.
This means that we will need a case distinction in our interpreter whether the function
argument is a closure or a continuation.</p></div>
      <div class="code"><code class='highlight'><pre></pre></code></div>
    </section>
    <section id='section-7'>
      <div class="docs"><p>Let&rsquo;s now study the interpreter for our new language. The branches for
<code>Num</code>, <code>Id</code>, <code>Add</code>, and <code>Fun</code> are straightforward applications of the CPS
transformation technique we already know.</p></div>
      <div class="code"><code class='highlight'><pre> <span class="k">def</span> <span class="n">eval</span><span class="o">(</span><span class="n">e</span><span class="k">:</span> <span class="kt">Exp</span><span class="o">,</span> <span class="n">env</span><span class="k">:</span> <span class="kt">Env</span><span class="o">,</span> <span class="n">k</span><span class="k">:</span> <span class="kt">Value</span> <span class="o">=&gt;</span> <span class="nc">Nothing</span><span class="o">)</span> <span class="k">:</span> <span class="kt">Nothing</span> <span class="o">=</span> <span class="n">e</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">Num</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">k</span><span class="o">(</span><span class="nc">NumV</span><span class="o">(</span><span class="n">n</span><span class="o">))</span>
  <span class="k">case</span> <span class="nc">Id</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">k</span><span class="o">(</span><span class="n">env</span><span class="o">(</span><span class="n">x</span><span class="o">))</span>
  <span class="k">case</span> <span class="nc">Add</span><span class="o">(</span><span class="n">l</span><span class="o">,</span><span class="n">r</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">{</span>
    <span class="n">eval</span><span class="o">(</span><span class="n">l</span><span class="o">,</span><span class="n">env</span><span class="o">,</span> <span class="n">lv</span> <span class="k">=&gt;</span> 
        <span class="n">eval</span><span class="o">(</span><span class="n">r</span><span class="o">,</span><span class="n">env</span><span class="o">,</span> <span class="n">rv</span> <span class="k">=&gt;</span>
          <span class="o">(</span><span class="n">lv</span><span class="o">,</span><span class="n">rv</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
            <span class="k">case</span> <span class="o">(</span><span class="nc">NumV</span><span class="o">(</span><span class="n">v1</span><span class="o">),</span> <span class="nc">NumV</span><span class="o">(</span><span class="n">v2</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="n">k</span><span class="o">(</span><span class="nc">NumV</span><span class="o">(</span><span class="n">v1</span><span class="o">+</span><span class="n">v2</span><span class="o">))</span>
            <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="n">sys</span><span class="o">.</span><span class="n">error</span><span class="o">(</span><span class="s">&quot;can only add numbers&quot;</span><span class="o">)</span>
          <span class="o">}))</span>
  <span class="o">}</span>
  <span class="k">case</span> <span class="n">f</span><span class="nd">@Fun</span><span class="o">(</span><span class="n">param</span><span class="o">,</span><span class="n">body</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">k</span><span class="o">(</span><span class="nc">ClosureV</span><span class="o">(</span><span class="n">f</span><span class="o">,</span> <span class="n">env</span><span class="o">))</span>
  </pre></code></div>
    </section>
    <section id='section-8'>
      <div class="docs"><p>In the application case we now need to distinguish whether the first argument
is a closure or a continuation. If it is a continuation, we ignore the
current continuation k and &ldquo;jump&rdquo; to the stored continuation by applying the
evaluated continuation argument to it.</p></div>
      <div class="code"><code class='highlight'><pre>  <span class="k">case</span> <span class="nc">App</span><span class="o">(</span><span class="n">f</span><span class="o">,</span><span class="n">a</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">eval</span><span class="o">(</span><span class="n">f</span><span class="o">,</span><span class="n">env</span><span class="o">,</span> <span class="n">cl</span> <span class="k">=&gt;</span> <span class="n">cl</span> <span class="k">match</span> <span class="o">{</span>
            <span class="k">case</span> <span class="nc">ClosureV</span><span class="o">(</span><span class="n">f</span><span class="o">,</span><span class="n">closureEnv</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">eval</span><span class="o">(</span><span class="n">a</span><span class="o">,</span><span class="n">env</span><span class="o">,</span> <span class="n">av</span> <span class="k">=&gt;</span> <span class="n">eval</span><span class="o">(</span><span class="n">f</span><span class="o">.</span><span class="n">body</span><span class="o">,</span> <span class="n">closureEnv</span> <span class="o">+</span> <span class="o">(</span><span class="n">f</span><span class="o">.</span><span class="n">param</span> <span class="o">-&gt;</span> <span class="n">av</span><span class="o">),</span><span class="n">k</span><span class="o">))</span>
            <span class="k">case</span> <span class="nc">ContV</span><span class="o">(</span><span class="n">f</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">eval</span><span class="o">(</span><span class="n">a</span><span class="o">,</span><span class="n">env</span><span class="o">,</span> <span class="n">av</span> <span class="k">=&gt;</span> <span class="n">f</span><span class="o">(</span><span class="n">av</span><span class="o">))</span>
            <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="n">sys</span><span class="o">.</span><span class="n">error</span><span class="o">(</span><span class="s">&quot;can only apply functions&quot;</span><span class="o">)</span>
  <span class="o">})</span></pre></code></div>
    </section>
    <section id='section-9'>
      <div class="docs"><p>Letcc is now surprisingly simple: We continue the evaluation in the body in an
extended environment in which param is bound to the current continuation k,
wrapped as a value using ContV.</p></div>
      <div class="code"><code class='highlight'><pre>  <span class="k">case</span> <span class="nc">Letcc</span><span class="o">(</span><span class="n">param</span><span class="o">,</span><span class="n">body</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">eval</span><span class="o">(</span><span class="n">body</span><span class="o">,</span> <span class="n">env</span><span class="o">+(</span><span class="n">param</span> <span class="o">-&gt;</span> <span class="nc">ContV</span><span class="o">(</span><span class="n">k</span><span class="o">)),</span> <span class="n">k</span><span class="o">)</span>  
<span class="o">}</span></pre></code></div>
    </section>
    <section id='section-10'>
      <div class="docs"><p>To make it easier to experiment with the interpreter this code provides the
right initialization to eval. We have to give eval a continuation which represents
the rest of the computation after eval is done. A small technical problem arises due to our 
usage of the return type &ldquo;Nothing&rdquo; for continuations, to emphasize that they
do not return: The only way to implement a value that has this type is a
function that does indeed not return. We do so by letting this function
throw an exception. To keep track of the returned value we store it temporarily
in a variable, catch the exception, and return the stored value.</p></div>
      <div class="code"><code class='highlight'><pre> 
<span class="k">def</span> <span class="n">starteval</span><span class="o">(</span><span class="n">e</span><span class="k">:</span> <span class="kt">Exp</span><span class="o">)</span> <span class="k">:</span> <span class="kt">Value</span> <span class="o">=</span> <span class="o">{</span>
  <span class="k">var</span> <span class="n">res</span> <span class="k">:</span> <span class="kt">Value</span> <span class="o">=</span> <span class="kc">null</span>
  <span class="k">val</span> <span class="n">s</span> <span class="k">:</span> <span class="kt">Value</span> <span class="o">=&gt;</span> <span class="nc">Nothing</span> <span class="k">=</span> <span class="o">(</span><span class="n">v</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">{</span> <span class="n">res</span> <span class="k">=</span> <span class="n">v</span><span class="o">;</span> <span class="n">sys</span><span class="o">.</span><span class="n">error</span><span class="o">(</span><span class="s">&quot;program terminated&quot;</span><span class="o">)</span> <span class="o">}</span>
  <span class="k">try</span> <span class="o">{</span> <span class="n">eval</span><span class="o">(</span><span class="n">e</span><span class="o">,</span> <span class="nc">Map</span><span class="o">.</span><span class="n">empty</span><span class="o">,</span> <span class="n">s</span><span class="o">)</span> <span class="o">}</span> <span class="k">catch</span> <span class="o">{</span> <span class="k">case</span> <span class="n">e</span><span class="k">:</span><span class="kt">Throwable</span> <span class="o">=&gt;</span> <span class="nc">Unit</span> <span class="o">}</span>
  <span class="n">res</span>
<span class="o">}</span></pre></code></div>
    </section>
    <section id='section-11'>
      <div class="docs"><p>Finally a small test of Letcc.</p>
</div>
      <div class="code"><code class='highlight'><pre><span class="k">val</span> <span class="n">testprog</span> <span class="k">=</span> <span class="nc">Add</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="nc">Letcc</span><span class="o">(</span><span class="-Symbol">&#39;k</span><span class="o">,</span> <span class="nc">Add</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="nc">App</span><span class="o">(</span><span class="-Symbol">&#39;k</span><span class="o">,</span> <span class="mi">3</span><span class="o">))))</span>

<span class="n">assert</span><span class="o">(</span><span class="n">starteval</span><span class="o">(</span><span class="n">testprog</span><span class="o">)</span> <span class="o">==</span> <span class="nc">NumV</span><span class="o">(</span><span class="mi">4</span><span class="o">))</span></pre></code></div>
    </section>
  </article>
</body>
